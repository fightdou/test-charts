apiVersion: v1
kind: ConfigMap
metadata:
  name: keystone-bin
  namespace: {{ .Release.Namespace | quote }}
data:
  bootstrap.sh: |
    #!/bin/bash
    set -ex
    # admin needs the admin role for the default domain
    openstack role add \
          --user="${OS_USERNAME}" \
          --domain="${OS_DEFAULT_DOMAIN}" \
          "admin"
  keystone-startup.sh: |-
    #!/bin/bash -x
    set -o errexit
    set -o pipefail
    connection="mysql+pymysql://{{ .Values.endpoints.oslo_db.username }}:${KEYSTONE_DATABASE_PASSWORD}@{{ index .Values "openstack-dep" "openstackEnv" "mariadbUrl" }}/{{ .Values.endpoints.oslo_db.database }}"
    sed -i "s#^connection = .*#connection = $connection#g" /etc/keystone/keystone.conf
    FERNET_KEY_DIR="/etc/keystone/fernet-keys"

    # Ensure Fernet keys are populated, check for 0 (staging) key
    n=0
    while [ ! -f "${FERNET_KEY_DIR}/0" ]; do
        if [ $n -lt 36 ]; then
            n=$(( n + 1 ))
            echo "ERROR: Fernet keys have not been populated, rechecking in 5 seconds"
            echo "DEBUG: ${FERNET_KEY_DIR} contents:"
            ls -l ${FERNET_KEY_DIR}
            sleep 5
        else
            echo "CRITICAL: Waited for 3 minutes - failing"
            exit 1
        fi
    done
    exec /usr/sbin/apache2 $@
  db-drop.sh: |
    #!/bin/bash
    set -ex
    mysql -uroot -p${ROOT_PASSWORD} -h ${KEYSTONE_DATABASE_HOST} -e "DROP DATABASE ${KEYSTONE_DATABASE_NAME}"

  db-init.sh: |
    #!/bin/bash
    set -ex
    mysql -uroot -p${ROOT_PASSWORD} -h ${KEYSTONE_DATABASE_HOST} -e "CREATE DATABASE ${KEYSTONE_DATABASE_NAME}"
    mysql -uroot -p${ROOT_PASSWORD} -h ${KEYSTONE_DATABASE_HOST} -e "GRANT ALL PRIVILEGES ON ${KEYSTONE_DATABASE_USER}.* TO '${KEYSTONE_DATABASE_USER}'@'localhost' IDENTIFIED BY '${KEYSTONE_DATABASE_PASSWORD}';"
    mysql -uroot -p${ROOT_PASSWORD} -h ${KEYSTONE_DATABASE_HOST} -e "GRANT ALL PRIVILEGES ON ${KEYSTONE_DATABASE_USER}.* TO '${KEYSTONE_DATABASE_USER}'@'%' IDENTIFIED BY '${KEYSTONE_DATABASE_PASSWORD}';" 

  db-sync.sh: |
    #!/bin/bash
    set -ex
    connection="mysql+pymysql://{{ .Values.endpoints.oslo_db.username }}:${KEYSTONE_DATABASE_PASSWORD}@{{ index .Values "openstack-dep" "openstackEnv" "mariadbUrl" }}/{{ .Values.endpoints.oslo_db.database }}"
    sed -i "s#^connection = .*#connection = $connection#g" /etc/keystone/keystone.conf
    keystone-manage --config-file=/etc/keystone/keystone.conf db_sync
    keystone-manage --config-file=/etc/keystone/keystone.conf bootstrap \
        --bootstrap-username ${OS_USERNAME} \
        --bootstrap-password ${OS_PASSWORD} \
        --bootstrap-project-name ${OS_PROJECT_NAME} \
        --bootstrap-admin-url ${OS_BOOTSTRAP_ADMIN_URL} \
        --bootstrap-public-url ${OS_BOOTSTRAP_PUBLIC_URL} \
        --bootstrap-internal-url ${OS_BOOTSTRAP_INTERNAL_URL} \
        --bootstrap-region-id ${OS_REGION_NAME}
    exec python3 /tmp/endpoint-update.py
  endpoint-update.py: |
    #!/usr/bin/env python
    import os
    import logging
    import sys
    from sqlalchemy import create_engine

    try:
        import ConfigParser
        PARSER_OPTS = {}
    except ImportError:
        import configparser as ConfigParser
        PARSER_OPTS = {"strict": False}

    # Create logger, console handler and formatter
    logger = logging.getLogger('OpenStack-Helm Keystone Endpoint management')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Set the formatter and add the handler
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    # Get the connection string for the service db
    if "OPENSTACK_CONFIG_FILE" in os.environ:
        os_conf = os.environ['OPENSTACK_CONFIG_FILE']
        if "OPENSTACK_CONFIG_DB_SECTION" in os.environ:
            os_conf_section = os.environ['OPENSTACK_CONFIG_DB_SECTION']
        else:
            logger.critical(
                'environment variable OPENSTACK_CONFIG_DB_SECTION not set')
            sys.exit(1)
        if "OPENSTACK_CONFIG_DB_KEY" in os.environ:
            os_conf_key = os.environ['OPENSTACK_CONFIG_DB_KEY']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_KEY not set')
            sys.exit(1)
        try:
            config = ConfigParser.RawConfigParser(**PARSER_OPTS)
            logger.info("Using {0} as db config source".format(os_conf))
            config.read(os_conf)
            logger.info("Trying to load db config from {0}:{1}".format(
                os_conf_section, os_conf_key))
            user_db_conn = config.get(os_conf_section, os_conf_key)
            logger.info("Got config from {0}".format(os_conf))
        except:
            logger.critical(
                "Tried to load config from {0} but failed.".format(os_conf))
            raise
    elif "DB_CONNECTION" in os.environ:
        user_db_conn = os.environ['DB_CONNECTION']
        logger.info('Got config from DB_CONNECTION env var')
    else:
        logger.critical(
            'Could not get db config, either from config file or env var')
        sys.exit(1)

    # User DB engine
    try:
        user_engine = create_engine(user_db_conn)
    except:
        logger.critical('Could not get user database config')
        raise

    # Set Internal Endpoint
    try:
        endpoint_url = os.environ['OS_BOOTSTRAP_INTERNAL_URL']
        cmd = ("update endpoint set url = %s where interface ='internal' and "
               "service_id = (select id from service where "
               "service.type = 'identity')")
        user_engine.execute(cmd, (endpoint_url,))
    except:
        logger.critical("Could not update internal endpoint")
        raise

    # Set Admin Endpoint
    try:
        endpoint_url = os.environ['OS_BOOTSTRAP_ADMIN_URL']
        cmd = ("update endpoint set url = %s where interface ='admin' "
               "and service_id = (select id from service where "
               "service.type = 'identity')")
        user_engine.execute(cmd, (endpoint_url,))
    except:
        logger.critical("Could not update admin endpoint")
        raise

    # Set Public Endpoint
    try:
        endpoint_url = os.environ['OS_BOOTSTRAP_PUBLIC_URL']
        cmd = ("update endpoint set url = %s where interface ='public' "
               "and service_id = (select id from service where "
               "service.type = 'identity')")
        user_engine.execute(cmd, (endpoint_url,))
    except:
        logger.critical("Could not update public endpoint")
        raise

    # Print endpoints
    try:
        endpoints = user_engine.execute(
            ("select interface, url from endpoint where service_id = "
             "(select id from service where service.type = 'identity')")
        ).fetchall()
        for row in endpoints:
            logger.info("endpoint ({0}): {1}".format(row[0], row[1]))
    except:
        logger.critical("Could not update endpoint")
        raise

    logger.info('Finished Endpoint Management')
  fernet-manage.py: |
    #!/usr/bin/env python
    import argparse
    import base64
    import errno
    import grp
    import logging
    import os
    import pwd
    import re
    import six
    import subprocess  #nosec
    import sys
    import time

    import requests

    FERNET_DIR = os.environ['KEYSTONE_KEYS_REPOSITORY']
    KEYSTONE_USER = os.environ['KEYSTONE_USER']
    KEYSTONE_GROUP = os.environ['KEYSTONE_GROUP']
    NAMESPACE = os.environ['KUBERNETES_NAMESPACE']

    # k8s connection data
    KUBE_HOST = None
    KUBE_CERT = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
    KUBE_TOKEN = None

    LOG_DATEFMT = "%Y-%m-%d %H:%M:%S"
    LOG_FORMAT = "%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s"
    logging.basicConfig(format=LOG_FORMAT, datefmt=LOG_DATEFMT)
    LOG = logging.getLogger(__name__)
    LOG.setLevel(logging.INFO)


    def read_kube_config():
        global KUBE_HOST, KUBE_TOKEN
        KUBE_HOST = "https://%s:%s" % ('kubernetes.default',
                                       os.environ['KUBERNETES_SERVICE_PORT'])
        with open('/var/run/secrets/kubernetes.io/serviceaccount/token', 'r') as f:
            KUBE_TOKEN = f.read()


    def get_secret_definition(name):
        url = '%s/api/v1/namespaces/%s/secrets/%s' % (KUBE_HOST, NAMESPACE, name)
        resp = requests.get(url,
                            headers={'Authorization': 'Bearer %s' % KUBE_TOKEN},
                            verify=KUBE_CERT)
        if resp.status_code != 200:
            LOG.error('Cannot get secret %s.', name)
            LOG.error(resp.text)
            return None
        return resp.json()


    def update_secret(name, secret):
        url = '%s/api/v1/namespaces/%s/secrets/%s' % (KUBE_HOST, NAMESPACE, name)
        resp = requests.put(url,
                            json=secret,
                            headers={'Authorization': 'Bearer %s' % KUBE_TOKEN},
                            verify=KUBE_CERT)
        if resp.status_code != 200:
            LOG.error('Cannot update secret %s.', name)
            LOG.error(resp.text)
            return False
        return True


    def read_from_files():
        keys = [name for name in os.listdir(FERNET_DIR) if os.path.isfile(FERNET_DIR + name)
                and re.match("^\d+$", name)]
        data = {}
        for key in keys:
            with open(FERNET_DIR + key, 'r') as f:
                data[key] = f.read()
        if len(list(keys)):
            LOG.debug("Keys read from files: %s", keys)
        else:
            LOG.warn("No keys were read from files.")
        return data


    def get_keys_data():
        keys = read_from_files()
        return dict([(key, base64.b64encode(value.encode()).decode())
                    for (key, value) in six.iteritems(keys)])


    def write_to_files(data):
        if not os.path.exists(os.path.dirname(FERNET_DIR)):
            try:
                os.makedirs(os.path.dirname(FERNET_DIR))
            except OSError as exc: # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise
            uid = pwd.getpwnam(KEYSTONE_USER).pw_uid
            gid = grp.getgrnam(KEYSTONE_GROUP).gr_gid
            os.chown(FERNET_DIR, uid, gid)

        for (key, value) in six.iteritems(data):
            with open(FERNET_DIR + key, 'w') as f:
                decoded_value = base64.b64decode(value).decode()
                f.write(decoded_value)
                LOG.debug("Key %s: %s", key, decoded_value)
        LOG.info("%s keys were written", len(data))


    def execute_command(cmd):
        LOG.info("Executing 'keystone-manage %s --keystone-user=%s "
                 "--keystone-group=%s' command.",
                 cmd, KEYSTONE_USER, KEYSTONE_GROUP)
        subprocess.call(['keystone-manage', cmd,  #nosec
                         '--keystone-user=%s' % KEYSTONE_USER,
                         '--keystone-group=%s' % KEYSTONE_GROUP])

    def main():
        parser = argparse.ArgumentParser()
        parser.add_argument('command', choices=['fernet_setup', 'fernet_rotate',
                                                'credential_setup',
                                                'credential_rotate'])
        args = parser.parse_args()

        is_credential = args.command.startswith('credential')

        SECRET_NAME = ('keystone-credential-keys' if is_credential else
                       'keystone-fernet-keys')

        read_kube_config()
        secret = get_secret_definition(SECRET_NAME)
        if not secret:
            LOG.error("Secret '%s' does not exist.", SECRET_NAME)
            sys.exit(1)

        if args.command in ('fernet_rotate', 'credential_rotate'):
            LOG.info("Copying existing %s keys from secret '%s' to %s.",
                     'credential' if is_credential else 'fernet', SECRET_NAME,
                     FERNET_DIR)
            write_to_files(secret['data'])

        if args.command in ('credential_setup', 'fernet_setup'):
            if secret.get('data', False):
                LOG.info('Keys already exist, skipping setup...')
                sys.exit(0)

        execute_command(args.command)

        LOG.info("Updating data for '%s' secret.", SECRET_NAME)
        updated_keys = get_keys_data()
        secret['data'] = updated_keys
        if not update_secret(SECRET_NAME, secret):
            sys.exit(1)
        LOG.info("%s fernet keys have been placed to secret '%s'",
                 len(updated_keys), SECRET_NAME)
        LOG.debug("Placed keys: %s", updated_keys)
        LOG.info("%s keys %s has been completed",
                 "Credential" if is_credential else 'Fernet',
                 "rotation" if args.command.endswith('_rotate') else "generation")

        if args.command == 'credential_rotate':
            # `credential_rotate` needs doing `credential_migrate` as well once all
            # of the nodes have the new keys. So we'll sleep configurable amount of
            # time to make sure k8s reloads the secrets in all pods and then
            # execute `credential_migrate`.

            migrate_wait = int(os.getenv('KEYSTONE_CREDENTIAL_MIGRATE_WAIT', "60"))
            LOG.info("Waiting %d seconds to execute `credential_migrate`.",
                     migrate_wait)
            time.sleep(migrate_wait)

            execute_command('credential_migrate')

    if __name__ == "__main__":
        main()
