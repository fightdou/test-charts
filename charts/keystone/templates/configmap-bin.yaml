apiVersion: v1
kind: ConfigMap
metadata:
  name: keystone-bin
  namespace: {{ .Release.Namespace | quote }}
data:
  keystone-api.sh: |
    #!/bin/bash
    set -ex
    COMMAND="${@:-start}"
    function start () {
      for KEYSTONE_WSGI_SCRIPT in keystone-wsgi-public; do
        cp -a $(type -p ${KEYSTONE_WSGI_SCRIPT}) /var/www/cgi-bin/keystone/
      done
      if [ -f /etc/apache2/envvars ]; then
         # Loading Apache2 ENV variables
         source /etc/apache2/envvars
      fi
      if [ -f /var/run/apache2/apache2.pid ]; then
         # Remove the stale pid for debian/ubuntu images
         rm -f /var/run/apache2/apache2.pid
      fi
      # Start Apache2
      exec apache2 -DFOREGROUND
    }
    function stop () {
      if [ -f /etc/apache2/envvars ]; then
         # Loading Apache2 ENV variables
         source /etc/apache2/envvars
      fi
      apache2 -k graceful-stop
    }
    $COMMAND
  bootstrap.sh: |
    #!/bin/bash
    set -ex
    # admin needs the admin role for the default domain
    openstack role add \
          --user="${OS_USERNAME}" \
          --domain="${OS_DEFAULT_DOMAIN}" \
          "admin"
  cred-clean.py: |

    #!/usr/bin/python

    # Drops db and user for an OpenStack Service:
    # Set ROOT_DB_CONNECTION and DB_CONNECTION environment variables to contain
    # SQLAlchemy strings for the root connection to the database and the one you
    # wish the service to use. Alternatively, you can use an ini formatted config
    # at the location specified by OPENSTACK_CONFIG_FILE, and extract the string
    # from the key OPENSTACK_CONFIG_DB_KEY, in the section specified by
    # OPENSTACK_CONFIG_DB_SECTION.

    import os
    import sys
    try:
        import ConfigParser
        PARSER_OPTS = {}
    except ImportError:
        import configparser as ConfigParser
        PARSER_OPTS = {"strict": False}
    import logging
    from sqlalchemy import create_engine

    # Create logger, console handler and formatter
    logger = logging.getLogger('OpenStack-Helm DB Drop')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Set the formatter and add the handler
    ch.setFormatter(formatter)
    logger.addHandler(ch)


    # Get the connection string for the service db root user
    if "ROOT_DB_CONNECTION" in os.environ:
        db_connection = os.environ['ROOT_DB_CONNECTION']
        logger.info('Got DB root connection')
    else:
        logger.critical('environment variable ROOT_DB_CONNECTION not set')
        sys.exit(1)

    mysql_x509 = os.getenv('MARIADB_X509', "")
    ssl_args = {}
    if mysql_x509:
        ssl_args = {'ssl': {'ca': '/etc/mysql/certs/ca.crt',
                            'key': '/etc/mysql/certs/tls.key',
                            'cert': '/etc/mysql/certs/tls.crt'}}

    # Get the connection string for the service db
    if "OPENSTACK_CONFIG_FILE" in os.environ:
        os_conf = os.environ['OPENSTACK_CONFIG_FILE']
        if "OPENSTACK_CONFIG_DB_SECTION" in os.environ:
            os_conf_section = os.environ['OPENSTACK_CONFIG_DB_SECTION']
        else:
            logger.critical(
                'environment variable OPENSTACK_CONFIG_DB_SECTION not set')
            sys.exit(1)
        if "OPENSTACK_CONFIG_DB_KEY" in os.environ:
            os_conf_key = os.environ['OPENSTACK_CONFIG_DB_KEY']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_KEY not set')
            sys.exit(1)
        try:
            config = ConfigParser.RawConfigParser(**PARSER_OPTS)
            logger.info("Using {0} as db config source".format(os_conf))
            config.read(os_conf)
            logger.info("Trying to load db config from {0}:{1}".format(
                os_conf_section, os_conf_key))
            user_db_conn = config.get(os_conf_section, os_conf_key)
            logger.info("Got config from {0}".format(os_conf))
        except:
            logger.critical(
                "Tried to load config from {0} but failed.".format(os_conf))
            raise
    elif "DB_CONNECTION" in os.environ:
        user_db_conn = os.environ['DB_CONNECTION']
        logger.info('Got config from DB_CONNECTION env var')
    else:
        logger.critical(
            'Could not get db config, either from config file or env var')
        sys.exit(1)

    # Root DB engine
    try:
        root_engine_full = create_engine(db_connection)
        root_user = root_engine_full.url.username
        root_password = root_engine_full.url.password
        drivername = root_engine_full.url.drivername
        host = root_engine_full.url.host
        port = root_engine_full.url.port
        root_engine_url = ''.join([drivername, '://', root_user, ':',
                                   root_password, '@', host, ':', str(port)])
        root_engine = create_engine(root_engine_url, connect_args=ssl_args)
        connection = root_engine.connect()
        connection.close()
        logger.info("Tested connection to DB @ {0}:{1} as {2}".format(
            host, port, root_user))
    except:
        logger.critical('Could not connect to database as root user')
        raise

    # User DB engine
    try:
        user_engine = create_engine(user_db_conn, connect_args=ssl_args)
        # Get our user data out of the user_engine
        database = user_engine.url.database
        user = user_engine.url.username
        password = user_engine.url.password
        logger.info('Got user db config')
    except:
        logger.critical('Could not get user database config')
        raise

    # Delete all entries from credential table

    try:
        cmd = "DELETE FROM credential"
        user_engine.execute(cmd)
        logger.info('Deleted all entries in credential table')
    except:
        logger.critical('Failed to clean up credential table in keystone db')
        raise

    logger.info('Finished DB Management')
  db-drop.py: |
    #!/usr/bin/env python

    # Drops db and user for an OpenStack Service:
    # Set ROOT_DB_CONNECTION and DB_CONNECTION environment variables to contain
    # SQLAlchemy strings for the root connection to the database and the one you
    # wish the service to use. Alternatively, you can use an ini formatted config
    # at the location specified by OPENSTACK_CONFIG_FILE, and extract the string
    # from the key OPENSTACK_CONFIG_DB_KEY, in the section specified by
    # OPENSTACK_CONFIG_DB_SECTION.

    import os
    import sys
    try:
        import ConfigParser
        PARSER_OPTS = {}
    except ImportError:
        import configparser as ConfigParser
        PARSER_OPTS = {"strict": False}
    import logging
    from sqlalchemy import create_engine

    # Create logger, console handler and formatter
    logger = logging.getLogger('OpenStack-Helm DB Drop')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Set the formatter and add the handler
    ch.setFormatter(formatter)
    logger.addHandler(ch)


    # Get the connection string for the service db root user
    if "ROOT_DB_CONNECTION" in os.environ:
        db_connection = os.environ['ROOT_DB_CONNECTION']
        logger.info('Got DB root connection')
    else:
        logger.critical('environment variable ROOT_DB_CONNECTION not set')
        sys.exit(1)

    mysql_x509 = os.getenv('MARIADB_X509', "")
    ssl_args = {}
    if mysql_x509:
        ssl_args = {'ssl': {'ca': '/etc/mysql/certs/ca.crt',
                            'key': '/etc/mysql/certs/tls.key',
                            'cert': '/etc/mysql/certs/tls.crt'}}

    # Get the connection string for the service db
    if "OPENSTACK_CONFIG_FILE" in os.environ:
        os_conf = os.environ['OPENSTACK_CONFIG_FILE']
        if "OPENSTACK_CONFIG_DB_SECTION" in os.environ:
            os_conf_section = os.environ['OPENSTACK_CONFIG_DB_SECTION']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_SECTION not set')
            sys.exit(1)
        if "OPENSTACK_CONFIG_DB_KEY" in os.environ:
            os_conf_key = os.environ['OPENSTACK_CONFIG_DB_KEY']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_KEY not set')
            sys.exit(1)
        try:
            config = ConfigParser.RawConfigParser(**PARSER_OPTS)
            logger.info("Using {0} as db config source".format(os_conf))
            config.read(os_conf)
            logger.info("Trying to load db config from {0}:{1}".format(
                os_conf_section, os_conf_key))
            user_db_conn = config.get(os_conf_section, os_conf_key)
            logger.info("Got config from {0}".format(os_conf))
        except:
            logger.critical("Tried to load config from {0} but failed.".format(os_conf))
            raise
    elif "DB_CONNECTION" in os.environ:
        user_db_conn = os.environ['DB_CONNECTION']
        logger.info('Got config from DB_CONNECTION env var')
    else:
        logger.critical('Could not get db config, either from config file or env var')
        sys.exit(1)

    # Root DB engine
    try:
        root_engine_full = create_engine(db_connection)
        root_user = root_engine_full.url.username
        root_password = root_engine_full.url.password
        drivername = root_engine_full.url.drivername
        host = root_engine_full.url.host
        port = root_engine_full.url.port
        root_engine_url = ''.join([drivername, '://', root_user, ':', root_password, '@', host, ':', str (port)])
        root_engine = create_engine(root_engine_url, connect_args=ssl_args)
        connection = root_engine.connect()
        connection.close()
        logger.info("Tested connection to DB @ {0}:{1} as {2}".format(
            host, port, root_user))
    except:
        logger.critical('Could not connect to database as root user')
        raise

    # User DB engine
    try:
        user_engine = create_engine(user_db_conn, connect_args=ssl_args)
        # Get our user data out of the user_engine
        database = user_engine.url.database
        user = user_engine.url.username
        password = user_engine.url.password
        logger.info('Got user db config')
    except:
        logger.critical('Could not get user database config')
        raise

    # Delete DB
    try:
        root_engine.execute("DROP DATABASE IF EXISTS {0}".format(database))
        logger.info("Deleted database {0}".format(database))
    except:
        logger.critical("Could not drop database {0}".format(database))
        raise

    # Delete DB User
    try:
        root_engine.execute("DROP USER IF EXISTS {0}".format(user))
        logger.info("Deleted user {0}".format(user))
    except:
        logger.critical("Could not delete user {0}".format(user))
        raise

    logger.info('Finished DB Management')
  db-init.py: |
    #!/usr/bin/env python

    # Creates db and user for an OpenStack Service:
    # Set ROOT_DB_CONNECTION and DB_CONNECTION environment variables to contain
    # SQLAlchemy strings for the root connection to the database and the one you
    # wish the service to use. Alternatively, you can use an ini formatted config
    # at the location specified by OPENSTACK_CONFIG_FILE, and extract the string
    # from the key OPENSTACK_CONFIG_DB_KEY, in the section specified by
    # OPENSTACK_CONFIG_DB_SECTION.

    import os
    import sys
    try:
        import ConfigParser
        PARSER_OPTS = {}
    except ImportError:
        import configparser as ConfigParser
        PARSER_OPTS = {"strict": False}
    import logging
    from sqlalchemy import create_engine

    # Create logger, console handler and formatter
    logger = logging.getLogger('OpenStack-Helm DB Init')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Set the formatter and add the handler
    ch.setFormatter(formatter)
    logger.addHandler(ch)


    # Get the connection string for the service db root user
    if "ROOT_PASSWORD" in os.environ:
        db_connection = "mysql+pymysql://root:" + os.environ['ROOT_PASSWORD'] + "@" + \
            os.environ['KEYSTONE_DATABASE_HOST'] + ":" + \
            os.environ['KEYSTONE_DATABASE_PORT'] + "/" + \
            os.environ['KEYSTONE_DATABASE_NAME']
        logger.info('Got DB root connection')
    else:
        logger.critical('environment variable ROOT_PASSWORD not set')
        sys.exit(1)

    mysql_x509 = os.getenv('MARIADB_X509', "")
    ssl_args = {}
    if mysql_x509:
        ssl_args = {'ssl': {'ca': '/etc/mysql/certs/ca.crt',
                    'key': '/etc/mysql/certs/tls.key',
                    'cert': '/etc/mysql/certs/tls.crt'}}

    # Get the connection string for the service db
    if "OPENSTACK_CONFIG_FILE" in os.environ:
        os_conf = os.environ['OPENSTACK_CONFIG_FILE']
        if "OPENSTACK_CONFIG_DB_SECTION" in os.environ:
            os_conf_section = os.environ['OPENSTACK_CONFIG_DB_SECTION']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_SECTION not set')
            sys.exit(1)
        if "OPENSTACK_CONFIG_DB_KEY" in os.environ:
            os_conf_key = os.environ['OPENSTACK_CONFIG_DB_KEY']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_KEY not set')
            sys.exit(1)
        try:
            config = ConfigParser.RawConfigParser(**PARSER_OPTS)
            logger.info("Using {0} as db config source".format(os_conf))
            config.read(os_conf)
            logger.info("Trying to load db config from {0}:{1}".format(
                os_conf_section, os_conf_key))
            user_db_conn = config.get(os_conf_section, os_conf_key)
            logger.info("Got config from {0}".format(os_conf))
        except:
            logger.critical("Tried to load config from {0} but failed.".format(os_conf))
            raise
    elif "DB_CONNECTION" in os.environ:
        user_db_conn = os.environ['DB_CONNECTION']
        logger.info('Got config from DB_CONNECTION env var')
    else:
        logger.critical('Could not get db config, either from config file or env var')
        sys.exit(1)

    # Root DB engine
    try:
        root_engine_full = create_engine(db_connection)
        root_user = root_engine_full.url.username
        root_password = root_engine_full.url.password
        drivername = root_engine_full.url.drivername
        host = root_engine_full.url.host
        port = root_engine_full.url.port
        root_engine_url = ''.join([drivername, '://', root_user, ':', root_password, '@', host, ':', str (port)])
        root_engine = create_engine(root_engine_url, connect_args=ssl_args)
        connection = root_engine.connect()
        connection.close()
        logger.info("Tested connection to DB @ {0}:{1} as {2}".format(
            host, port, root_user))
    except:
        logger.critical('Could not connect to database as root user')
        raise

    # User DB engine
    try:
        user_engine = create_engine(user_db_conn, connect_args=ssl_args)
        # Get our user data out of the user_engine
        database = user_engine.url.database
        user = user_engine.url.username
        password = user_engine.url.password
        logger.info('Got user db config')
    except:
        logger.critical('Could not get user database config')
        raise

    # Create DB
    try:
        root_engine.execute("CREATE DATABASE IF NOT EXISTS {0}".format(database))
        logger.info("Created database {0}".format(database))
    except:
        logger.critical("Could not create database {0}".format(database))
        raise

    # Create DB User
    try:
        root_engine.execute(
            "GRANT ALL ON `{0}`.* TO \'{1}\'@\'%%\' IDENTIFIED BY \'{2}\' {3}".format(
                database, user, password, mysql_x509))
        logger.info("Created user {0} for {1}".format(user, database))
    except:
        logger.critical("Could not create user {0} for {1}".format(user, database))
        raise

    # Test connection
    try:
        connection = user_engine.connect()
        connection.close()
        logger.info("Tested connection to DB @ {0}:{1}/{2} as {3}".format(
            host, port, database, user))
    except:
        logger.critical('Could not connect to database as user')
        raise

    logger.info('Finished DB Management')
  db-sync.sh: |
    #!/bin/bash
    set -ex
    keystone-manage --config-file=/etc/keystone/keystone.conf db_sync
    keystone-manage --config-file=/etc/keystone/keystone.conf bootstrap \
        --bootstrap-username ${OS_USERNAME} \
        --bootstrap-password ${OS_PASSWORD} \
        --bootstrap-project-name ${OS_PROJECT_NAME} \
        --bootstrap-admin-url ${OS_BOOTSTRAP_ADMIN_URL} \
        --bootstrap-public-url ${OS_BOOTSTRAP_PUBLIC_URL} \
        --bootstrap-internal-url ${OS_BOOTSTRAP_INTERNAL_URL} \
        --bootstrap-region-id ${OS_REGION_NAME}
    exec python /tmp/endpoint-update.py
  endpoint-update.py: |
    #!/usr/bin/env python
    import os
    import logging
    import sys
    from sqlalchemy import create_engine

    try:
        import ConfigParser
        PARSER_OPTS = {}
    except ImportError:
        import configparser as ConfigParser
        PARSER_OPTS = {"strict": False}

    # Create logger, console handler and formatter
    logger = logging.getLogger('OpenStack-Helm Keystone Endpoint management')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Set the formatter and add the handler
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    # Get the connection string for the service db
    if "OPENSTACK_CONFIG_FILE" in os.environ:
        os_conf = os.environ['OPENSTACK_CONFIG_FILE']
        if "OPENSTACK_CONFIG_DB_SECTION" in os.environ:
            os_conf_section = os.environ['OPENSTACK_CONFIG_DB_SECTION']
        else:
            logger.critical(
                'environment variable OPENSTACK_CONFIG_DB_SECTION not set')
            sys.exit(1)
        if "OPENSTACK_CONFIG_DB_KEY" in os.environ:
            os_conf_key = os.environ['OPENSTACK_CONFIG_DB_KEY']
        else:
            logger.critical('environment variable OPENSTACK_CONFIG_DB_KEY not set')
            sys.exit(1)
        try:
            config = ConfigParser.RawConfigParser(**PARSER_OPTS)
            logger.info("Using {0} as db config source".format(os_conf))
            config.read(os_conf)
            logger.info("Trying to load db config from {0}:{1}".format(
                os_conf_section, os_conf_key))
            user_db_conn = config.get(os_conf_section, os_conf_key)
            logger.info("Got config from {0}".format(os_conf))
        except:
            logger.critical(
                "Tried to load config from {0} but failed.".format(os_conf))
            raise
    elif "DB_CONNECTION" in os.environ:
        user_db_conn = os.environ['DB_CONNECTION']
        logger.info('Got config from DB_CONNECTION env var')
    else:
        logger.critical(
            'Could not get db config, either from config file or env var')
        sys.exit(1)

    # User DB engine
    try:
        user_engine = create_engine(user_db_conn)
    except:
        logger.critical('Could not get user database config')
        raise

    # Set Internal Endpoint
    try:
        endpoint_url = os.environ['OS_BOOTSTRAP_INTERNAL_URL']
        cmd = ("update endpoint set url = %s where interface ='internal' and "
               "service_id = (select id from service where "
               "service.type = 'identity')")
        user_engine.execute(cmd, (endpoint_url,))
    except:
        logger.critical("Could not update internal endpoint")
        raise

    # Set Admin Endpoint
    try:
        endpoint_url = os.environ['OS_BOOTSTRAP_ADMIN_URL']
        cmd = ("update endpoint set url = %s where interface ='admin' "
               "and service_id = (select id from service where "
               "service.type = 'identity')")
        user_engine.execute(cmd, (endpoint_url,))
    except:
        logger.critical("Could not update admin endpoint")
        raise

    # Set Public Endpoint
    try:
        endpoint_url = os.environ['OS_BOOTSTRAP_PUBLIC_URL']
        cmd = ("update endpoint set url = %s where interface ='public' "
               "and service_id = (select id from service where "
               "service.type = 'identity')")
        user_engine.execute(cmd, (endpoint_url,))
    except:
        logger.critical("Could not update public endpoint")
        raise

    # Print endpoints
    try:
        endpoints = user_engine.execute(
            ("select interface, url from endpoint where service_id = "
             "(select id from service where service.type = 'identity')")
        ).fetchall()
        for row in endpoints:
            logger.info("endpoint ({0}): {1}".format(row[0], row[1]))
    except:
        logger.critical("Could not update endpoint")
        raise

    logger.info('Finished Endpoint Management')
  fernet-manage.py: |
    #!/usr/bin/env python
    import argparse
    import base64
    import errno
    import grp
    import logging
    import os
    import pwd
    import re
    import six
    import subprocess  #nosec
    import sys
    import time

    import requests

    FERNET_DIR = os.environ['KEYSTONE_KEYS_REPOSITORY']
    KEYSTONE_USER = os.environ['KEYSTONE_USER']
    KEYSTONE_GROUP = os.environ['KEYSTONE_GROUP']
    NAMESPACE = os.environ['KUBERNETES_NAMESPACE']

    # k8s connection data
    KUBE_HOST = None
    KUBE_CERT = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
    KUBE_TOKEN = None

    LOG_DATEFMT = "%Y-%m-%d %H:%M:%S"
    LOG_FORMAT = "%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s"
    logging.basicConfig(format=LOG_FORMAT, datefmt=LOG_DATEFMT)
    LOG = logging.getLogger(__name__)
    LOG.setLevel(logging.INFO)


    def read_kube_config():
        global KUBE_HOST, KUBE_TOKEN
        KUBE_HOST = "https://%s:%s" % ('kubernetes.default',
                                       os.environ['KUBERNETES_SERVICE_PORT'])
        with open('/var/run/secrets/kubernetes.io/serviceaccount/token', 'r') as f:
            KUBE_TOKEN = f.read()


    def get_secret_definition(name):
        url = '%s/api/v1/namespaces/%s/secrets/%s' % (KUBE_HOST, NAMESPACE, name)
        resp = requests.get(url,
                            headers={'Authorization': 'Bearer %s' % KUBE_TOKEN},
                            verify=KUBE_CERT)
        if resp.status_code != 200:
            LOG.error('Cannot get secret %s.', name)
            LOG.error(resp.text)
            return None
        return resp.json()


    def update_secret(name, secret):
        url = '%s/api/v1/namespaces/%s/secrets/%s' % (KUBE_HOST, NAMESPACE, name)
        resp = requests.put(url,
                            json=secret,
                            headers={'Authorization': 'Bearer %s' % KUBE_TOKEN},
                            verify=KUBE_CERT)
        if resp.status_code != 200:
            LOG.error('Cannot update secret %s.', name)
            LOG.error(resp.text)
            return False
        return True


    def read_from_files():
        keys = [name for name in os.listdir(FERNET_DIR) if os.path.isfile(FERNET_DIR + name)
                and re.match("^\d+$", name)]
        data = {}
        for key in keys:
            with open(FERNET_DIR + key, 'r') as f:
                data[key] = f.read()
        if len(list(keys)):
            LOG.debug("Keys read from files: %s", keys)
        else:
            LOG.warn("No keys were read from files.")
        return data


    def get_keys_data():
        keys = read_from_files()
        return dict([(key, base64.b64encode(value.encode()).decode())
                    for (key, value) in six.iteritems(keys)])


    def write_to_files(data):
        if not os.path.exists(os.path.dirname(FERNET_DIR)):
            try:
                os.makedirs(os.path.dirname(FERNET_DIR))
            except OSError as exc: # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise
            uid = pwd.getpwnam(KEYSTONE_USER).pw_uid
            gid = grp.getgrnam(KEYSTONE_GROUP).gr_gid
            os.chown(FERNET_DIR, uid, gid)

        for (key, value) in six.iteritems(data):
            with open(FERNET_DIR + key, 'w') as f:
                decoded_value = base64.b64decode(value).decode()
                f.write(decoded_value)
                LOG.debug("Key %s: %s", key, decoded_value)
        LOG.info("%s keys were written", len(data))


    def execute_command(cmd):
        LOG.info("Executing 'keystone-manage %s --keystone-user=%s "
                 "--keystone-group=%s' command.",
                 cmd, KEYSTONE_USER, KEYSTONE_GROUP)
        subprocess.call(['keystone-manage', cmd,  #nosec
                         '--keystone-user=%s' % KEYSTONE_USER,
                         '--keystone-group=%s' % KEYSTONE_GROUP])

    def main():
        parser = argparse.ArgumentParser()
        parser.add_argument('command', choices=['fernet_setup', 'fernet_rotate',
                                                'credential_setup',
                                                'credential_rotate'])
        args = parser.parse_args()

        is_credential = args.command.startswith('credential')

        SECRET_NAME = ('keystone-credential-keys' if is_credential else
                       'keystone-fernet-keys')

        read_kube_config()
        secret = get_secret_definition(SECRET_NAME)
        if not secret:
            LOG.error("Secret '%s' does not exist.", SECRET_NAME)
            sys.exit(1)

        if args.command in ('fernet_rotate', 'credential_rotate'):
            LOG.info("Copying existing %s keys from secret '%s' to %s.",
                     'credential' if is_credential else 'fernet', SECRET_NAME,
                     FERNET_DIR)
            write_to_files(secret['data'])

        if args.command in ('credential_setup', 'fernet_setup'):
            if secret.get('data', False):
                LOG.info('Keys already exist, skipping setup...')
                sys.exit(0)

        execute_command(args.command)

        LOG.info("Updating data for '%s' secret.", SECRET_NAME)
        updated_keys = get_keys_data()
        secret['data'] = updated_keys
        if not update_secret(SECRET_NAME, secret):
            sys.exit(1)
        LOG.info("%s fernet keys have been placed to secret '%s'",
                 len(updated_keys), SECRET_NAME)
        LOG.debug("Placed keys: %s", updated_keys)
        LOG.info("%s keys %s has been completed",
                 "Credential" if is_credential else 'Fernet',
                 "rotation" if args.command.endswith('_rotate') else "generation")

        if args.command == 'credential_rotate':
            # `credential_rotate` needs doing `credential_migrate` as well once all
            # of the nodes have the new keys. So we'll sleep configurable amount of
            # time to make sure k8s reloads the secrets in all pods and then
            # execute `credential_migrate`.

            migrate_wait = int(os.getenv('KEYSTONE_CREDENTIAL_MIGRATE_WAIT', "60"))
            LOG.info("Waiting %d seconds to execute `credential_migrate`.",
                     migrate_wait)
            time.sleep(migrate_wait)

            execute_command('credential_migrate')

    if __name__ == "__main__":
        main()
